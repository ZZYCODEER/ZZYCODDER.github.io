<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Objective-C-(四)-多线程 | zzy&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍多线程前先来理解下进程和线程的概念： 进程：一个在前台正在运行的应用程序就是一个进程。比如打开的微信APP就是一个进程。 线程：微信APP可以聊天，发图片，而做这些事情都是要通过线程来做的。线程就是执行任务的基本单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，线程是进程的一部分。 多线程就是多个线程并发处理任务的技术，可以充分利用多核CPU的资源，提升执行性能。 iOS中处理和操作">
<meta name="keywords" content="Objective-C-(四)-多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C-(四)-多线程">
<meta property="og:url" content="https://zzycodder.github.io/2019/01/01/Objective-C-四-多线程/index.html">
<meta property="og:site_name" content="zzy&#39;s Blog">
<meta property="og:description" content="介绍多线程前先来理解下进程和线程的概念： 进程：一个在前台正在运行的应用程序就是一个进程。比如打开的微信APP就是一个进程。 线程：微信APP可以聊天，发图片，而做这些事情都是要通过线程来做的。线程就是执行任务的基本单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，线程是进程的一部分。 多线程就是多个线程并发处理任务的技术，可以充分利用多核CPU的资源，提升执行性能。 iOS中处理和操作">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-01T06:24:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C-(四)-多线程">
<meta name="twitter:description" content="介绍多线程前先来理解下进程和线程的概念： 进程：一个在前台正在运行的应用程序就是一个进程。比如打开的微信APP就是一个进程。 线程：微信APP可以聊天，发图片，而做这些事情都是要通过线程来做的。线程就是执行任务的基本单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，线程是进程的一部分。 多线程就是多个线程并发处理任务的技术，可以充分利用多核CPU的资源，提升执行性能。 iOS中处理和操作">
  
    <link rel="alternate" href="/atom.xml" title="zzy&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zzy&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">busy living busy dying</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zzycodder.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Objective-C-四-多线程" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/01/Objective-C-四-多线程/" class="article-date">
  <time datetime="2019-01-01T06:22:12.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Objective-C-(四)-多线程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍多线程前先来理解下进程和线程的概念：</p>
<p>进程：一个在前台正在运行的应用程序就是一个进程。比如打开的微信APP就是一个进程。</p>
<p>线程：微信APP可以聊天，发图片，而做这些事情都是要通过线程来做的。线程就是执行任务的基本单元，是CPU调度和分派的基本单位。一个进程可以有多个线程，线程是进程的一部分。</p>
<p>多线程就是多个线程并发处理任务的技术，可以充分利用多核CPU的资源，提升执行性能。</p>
<p>iOS中处理和操作线程的方案有<code>Pthreads</code>、<code>NSThread</code>、<code>GCD</code>、<code>NSOperation &amp;&amp; NSOperationQueue</code>。<code>Pthreads</code> 比较底层，没有用过，就不说了，主要来说下<code>NSThread</code>、<code>GCD</code>和<code>NSOperation &amp;&amp; NSOperationQueue</code>。</p>
<p>介绍之前先说下两个概念：<strong>同步/异步，串行/并发</strong></p>
<ul>
<li><code>同步</code>是指在执行任务的时候，会等待当前这个任务执行完毕后再继续向下执行。如果当前这个任务没有执行完毕，那么就会阻塞当前的线程直到这个任务执行完成。</li>
<li><code>异步</code>是指在执行任务的时候，不会等待当前这个任务执行完毕就会继续向下执行。即使当前这个任务没有执行完，也会立刻执行下面的任务。</li>
</ul>
<p><code>同步</code>和<code>异步</code>的区别可以理解为：例如方法A内部中有个方法B，当前的方法A内部执行到了方法B，如果是<code>同步</code>，会等这个方法B执行完返回后才会向下执行，如果方法B没有返回，当前的线程就会一直卡住不向下执行；如果是<code>异步</code>的话这个方法B会立刻返回，然后继续向下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//方法A</span><br><span class="line">- (void)methodA &#123;</span><br><span class="line">    ....其他任务</span><br><span class="line">    [self methodB]</span><br><span class="line">    ....其他任务</span><br><span class="line">&#125;</span><br><span class="line">//方法B</span><br><span class="line">- (void)methodB &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>串行</code>：执行任务的时候按顺序执行，一次只能执行一个任务。当前的任务没有执行完，不会执行下一个。</li>
<li><code>并发</code>：执行任务的时候可以多个任务同时执行。</li>
</ul>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread是一个直接面向线程的类，提供了很多可以操作线程的方法。最简单的创建一个线程：</p>
<p><code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(doThead:) object:@&quot;zzy&quot;];</code> </p>
<p>这样就创建了一个线程实例<code>thread</code>，<code>thread</code>通过<code>doThead:</code>这个方法执行任务。但是这个时候创建的线程并没有启动执行任务，需要调用下<code>start</code>方法：<code>[thread start];</code>这样线程就开始执行任务了。<code>object:@&quot;zzy&quot;</code>参数会在线程执行<code>doThead:</code>方法的时候被作为参数传入。</p>
<p>我们也可以给一个线程设置一个名字作为标记：<code>[thread setName:@&quot;zzy&quot;];</code> 通过<code>[NSThread currentThread]</code>获取当前线程的信息，打印出当前这个线程可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX[67222:788960] thread = &lt;NSThread: 0x600000662600&gt;&#123;number = 3, name = zzy&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>name</code>我们可以找到我们设置的是哪个<code>thread</code>。</p>
<p>NSThread 也提供了一些关于线程的状态信息，例如：<code>executing</code>，<code>finished</code>，<code>cancelled</code>，分别表示当前的线程正在执行，完成，取消的状态。但是<code>cancelled</code>只是一个标记状态，并不会取消线程，如果想强制退出当前的线程，可以通过<code>[NSThread exit];</code>。</p>
<p>NSThread的使用比较简单，主要是注意通过NSThread创建的子线程中指定NSTimer计时器的情况。由于子线程中的runloop默认不启动，所以当添加一个定时器重复执行任务的时候要指定启动runloop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)doThead:(NSString *)object &#123;    </span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerRepeatAction:) userInfo:@&#123;@&quot;id&quot;:@&quot;zzy&quot;&#125; repeats:YES];</span><br><span class="line">    [timer fire];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD是平时最常用的多线程处理的方案了，我们将任务放进block中追加到队列里，系统就会自动为我们创建相应的线程去处理任务，并且任务完成后在合适的时机销毁线程，整个过程中不需要我们去直接操作线程，所以使用起来比较方便。</p>
<p>GCD有三种队列：串行队列，并发队列，主队列（特殊的串行队列，队列中的任务一定会在主线程中执行）</p>
<p>GCD获取队列的方式有两种：</p>
<ul>
<li><p>第一种通过<code>dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</code>函数直接创建队列，第一个参数的队列的名称，方便调试使用，第二个是队列的类型。传<code>NULL</code>或<code>DISPATCH_QUEUE_SERIAL</code>表示串行队列，传<code>DISPATCH_QUEUE_CONCURRENT</code>表示并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;zzy&quot;, NULL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一种是直接获取系统提供好的两个队列：</p>
<ul>
<li><code>dispatch_get_main_queue</code>：主队列，运行在主线程中的串行队列</li>
<li><code>dispatch_get_global_queue</code>：全局队列，也就是并发队列，通过这个函数的第一个参数还可以指定队列的优先级。</li>
</ul>
</li>
</ul>
<p>GCD中平时常用的有以下几个函数：</p>
<ul>
<li><code>dispathc_once</code>：确保函数中的block只执行一次，而且是线程安全的。常用来实现单利对象。</li>
<li><code>dispatch_after</code>：延迟指定的时间之后提交某个任务（<strong>这里是延迟某个时间提交任务，而不是延迟某个时间执行任务</strong>）。常用做一个定时操作。</li>
<li><code>dispatch_suspend</code>&amp;&amp;<code>dispatch_resume</code>：暂停和恢复某个队列</li>
<li><code>dispatch_apply</code>：循环将某些任务加入到某个队列当中</li>
<li><code>dispatch_set_target_queue</code>：可以设置目标队列的优先级，让目标队列的优先级和指定的队列优先级一样。（由于<code>dispatch_queue_create</code>函数创建的队列没有提供设置优先级的参数，默认是默认的优先级，所以可以用这个函数来设置其他优先级，例如<code>dispatch_set_target_queue(targetQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));</code>）</li>
<li><code>dispatch_barrier_async</code>：在一个并发队列中，先并行处理一部分任务，然后同步执行<code>dispatch_barrier_async</code>中的任务（只执行当前block中的一个任务，其他任务不执行），<code>dispatch_barrier_async</code>任务执行完成后，然后再恢复当前队列并行执行的任务。常用来处理在多线程数据读取的时候插入写入操作（写入操作必须是线程安全的）。</li>
</ul>
<p>这里主要介绍下平时处理异步任务的时候比较有用的任务组<code>dispatch_group_t</code>和信号量<code>dispatch_semaphore_t</code>。</p>
<h4 id="dispatch-group-t"><a href="#dispatch-group-t" class="headerlink" title="dispatch_group_t"></a>dispatch_group_t</h4><p><code>dispatch_group_t</code>是一个任务组，可以将几个并发任务一起放到任务组里面，当这几个并发任务都执行完成后，同步得到通知回调。涉及到两个常用的函数：<code>dispatch_wait</code>和<code>dispatch_notify</code>。</p>
<p><code>dispatch_wait</code>是一个同步的函数，一旦被调用该函数就会一直处于调用的状态而不返回，<strong>直到dispatch group内的任务都执行完成或者经过<code>dispatch_wait</code>中第二参数指定的时间后它才会返回</strong>，否则它会一直阻塞当前的线程，无法继续执行。如果<code>dispatch_wait</code>函数返回值为0，说明group内的任务已经执行完毕；如果返回值不为0，说明经过了指定的时间group内的任务依然没有执行完。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathGroup &#123;</span><br><span class="line">/**</span><br><span class="line">	使用dispatch_group_t也可以向group中指定不同优先级的队列，不一定非要是同一个队列，他们都归属同一个group</span><br><span class="line">*/</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务一&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, highQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;高优先级任务&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_wait(group, DISPATCH_TIME_FOREVER);    </span><br><span class="line">    NSLog(@&quot;任务执行完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-01 10:09:53.092345+0800 XXX[12671:1433314] 高优先级任务</span><br><span class="line">2019-01-01 10:09:55.094704+0800 XXX[12671:1433327] 任务二</span><br><span class="line">2019-01-01 10:09:55.094704+0800 XXX[12671:1433313] 任务一</span><br><span class="line">2019-01-01 10:09:55.095105+0800 XXX[12671:1433235] 任务执行完成</span><br></pre></td></tr></table></figure>
<p>可以看到<code>dispatch_wait</code> 会一直阻塞当前的线程，直到任务执行完成（这里指定的时间是永久等待，也可以自己定义临界时间）。</p>
<p>而<code>dispatch_notify</code>提供了一个异步执行的函数，它不会阻塞当前的线程，但是会监听dispatch group的任务执行情况，一旦group内的都执行完成后就会调用<code>dispatch_notify</code>函数。<code>dispatch_notify(object, queue, notification_block)</code>函数提供了三个参数，第一个参数就是监听的dispatch group，另外两个参数提供了可以让某个任务在指定队列中执行的功能。也就说当dispatch group内的任务都完成后会通知<code>dispatch_notify</code>然后可以进行一些完成后的处理操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathGroup &#123;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务一&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, highQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;高优先级任务&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch group执行完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务执行完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-01-01 10:28:40.864817+0800 XXX[12801:1454449] 任务执行完成</span><br><span class="line">2019-01-01 10:28:40.864821+0800 XXX[12801:1454557] 高优先级任务</span><br><span class="line">2019-01-01 10:28:42.865759+0800 XXX[12801:1454555] 任务二</span><br><span class="line">2019-01-01 10:28:42.865760+0800 XXX[12801:1454558] 任务一</span><br><span class="line">2019-01-01 10:28:42.866070+0800 XXX[12801:1454449] dispatch group执行完成</span><br></pre></td></tr></table></figure>
<p><code>dispatch_notify</code>函数提供的这种获取dispatch group内任务完成后的通知，然后再异步执行处理很常用。</p>
<p>如果对同步、异步理解的不够深刻的话，使用<code>dispatch_group_async</code>函数的时候可能会导致一个错误的认识。比如在<code>dispatch_group_async</code>中添加几个网络请求的任务，会发现请求还没完成就执行了<code>dispatch_notify</code>回调。这是因为发起网络请求本身就是一个任务，在把这个任务通过block追加到<code>dispatch_group_async</code>中的队列后就算完成了，并不会等待网络请求的完成，因为网络请求本身也是异步的。所以在遇到这种异步操作情况的时候，可以用另外一对函数将来判定任务完成情况：<code>dispatch_group_enter</code>（添加到group中）、<code>dispatch_group_leave</code>（执行完成退出group）。</p>
<p>这两个函数必须同时存在，类似于引用计数，这是对group内的任务的递增和递减，如果只有递增没有递减，那么group的任务就会永远执行不完，也就一直不会回调<code>dispatch_notify</code>函数，或者<code>dispatch_wait</code>函数一直不会返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispathGroup &#123;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务一&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(defaultQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(highQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;高优先级任务&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch group执行完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务执行完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h4><p><code>dispatch_semaphore_t</code> 信号量一共就三个函数，用起来比较简单，只是需要结合不同的场景去理解才能发挥很大的用处：</p>
<ul>
<li><code>dispatch_semaphore_create</code> : 创建一个信号量，并指定信号的初始化个数</li>
<li><code>dispatch_semaphore_wait</code>：锁住当前的线程，等待信号的计数大于等于1，然后将计数减去1，并且该函数返回。如果信号是0，则该函数一直不返回，阻塞当前的线程。</li>
<li><code>dispatch_semaphore_signal</code>：释放信号，让信号计数加1</li>
</ul>
<p>在很多开源库中都使用<code>dispatch_semaphore_t</code>作为锁来处理多线程时对数据写入的保护。例如下面示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatchSemaphore &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个异步并发线程中，对数组进行添加元素的操作。由于会有多个线程同时对array进行写入操作，如果不加<code>dispatch_semaphore_t</code>则很可能会导致内存访问错误导致程序终止。</p>
<p>加了<code>dispatch_semaphore_t</code>后，将信号的计数指定为1，每当执行一次<code>dispatch_semaphore_wait</code>函数后，信号就会减1，此时信号为0，则阻塞线程无法执行下面的<code>[array addObject:[NSNumber numberWithInt:i]];</code>方法，直到前面的线程执行完对数组的操作然后执行<code>dispatch_semaphore_signal</code>函数使信号加1，当前的线程才能访问数组，这样一来，每次对数组的访问操作都只能有一个线程，就保护了数据访问的安全。当然对本例也可以用其他方法来处理，例如指定一个串行队列。</p>
<p>通过<code>dispatch_semaphore_t</code>信号量和<code>dispatch_group_t</code>的组合，也能实现代替上面例子中使用<code>dispatch_group_enter</code>、<code>dispatch_group_leave</code>的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatchSemaphoreGroup &#123;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        dispatch_async(defaultQueue, ^&#123;</span><br><span class="line">            sleep(2);</span><br><span class="line">            NSLog(@&quot;任务一&quot;);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, defaultQueue, ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">        dispatch_async(defaultQueue, ^&#123;</span><br><span class="line">            sleep(2);</span><br><span class="line">            NSLog(@&quot;任务二&quot;);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch group执行完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务执行完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每次追加block中的任务到group的时候，都先创建一个信号计数为0的信号量，然后开启一个block内部的异步任务的执行，在block的最后使用<code>dispatch_semaphore_wait</code>锁住当前的线程，让当前的block无法返回，则group的任务就一直无法完成。直到block内部的这个异步任务执行完成后释放信号，通过<code>dispatch_semaphore_signal</code>让信号加1，则block返回，group内的任务完成，再回调<code>dispatch_notify</code>函数。</p>
<p>信号量在网络请求的同步处理，资源竞争等情况下可以发挥很大的用处，可以使用信号量来解决这些问题。</p>
<h3 id="NSOperation-amp-amp-NSOperationQueue"><a href="#NSOperation-amp-amp-NSOperationQueue" class="headerlink" title="NSOperation &amp;&amp; NSOperationQueue"></a>NSOperation &amp;&amp; NSOperationQueue</h3><p>相对于GCD都是纯C的函数，NSOperation提供了一个更高层面面向对象的多线程处理方案。NSOperation是用来封装任务的一个类。我们把需要执行的任务封装进NSOperation实例当中，通过调用<code>start</code>方法它会自动去执行这些任务。它也提供了很多种的状态便于我们观测了解当前任务的执行状态，例如：<code>isCancelled</code>，<code>isReady</code>，<code>isExecuting</code>，<code>isFinished</code>等。NSOperation是一个抽象类，我们不能直接使用NSOperation类的去处理任务，系统提供了两个子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>方便我们使用，也可以自己创建一个NSOperation的子类去实现。</p>
<p><code>NSInvocationOperation</code>提供了一种<code>target - action</code>模式响应的处理任务类，通过指定<code>target</code>，去对应执行<code>action</code>操作。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)invocationOperationAction &#123;</span><br><span class="line">    NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperationAction:) object:@&quot;zzy&quot;];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)invocationOperationAction:(id)userInfo &#123;</span><br><span class="line">    NSLog(@&quot;userInfo = %@&quot;, userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSBlockOperation</code>则提供了block的方式去处理任务，通过把任务封装进block块中对应去执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *operaion = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">      NSLog(@&quot;operation1&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p>还可以给operation中添加多个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[operaion addExecutionBlock:^&#123;</span><br><span class="line">      NSLog(@&quot;operation2&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[operaion addExecutionBlock:^&#123;</span><br><span class="line">      NSLog(@&quot;operation3&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p>只有当这些添加的Block中的任务都执行完，这个operation才算执行完成。</p>
<p>需要注意的是，如果通过手动执行NSOperation的<code>start</code>方法去启动任务的话，<code>start</code>方法是<code>同步</code>的。NSOperation提供了一个只读属性<code>isAsynchronous</code>（也可以通过<code>concurrent</code>）来标识当前NSOperation是否是异步执行，默认这个属性是NO。如同上面关于<code>同步</code>的解释，<code>start</code>方法会阻塞当前调用它的线程，直到operation的操作都完成。看下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockOperationThread &#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(synchronousOperation) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)synchronousOperation &#123;</span><br><span class="line">    NSBlockOperation *operaion = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;operationBlock1&quot;);</span><br><span class="line">        NSLog(@&quot;operation1 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operaion addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operationBlock2&quot;);</span><br><span class="line">        NSLog(@&quot;operation2 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operaion start];</span><br><span class="line">    NSLog(@&quot;synchronousOperation....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-01-01 11:17:30.504408+0800 XXX[11341:1269966] operationBlock2</span><br><span class="line">2019-01-01 11:17:30.504966+0800 XXX[11341:1269966] operation2 Thread = &lt;NSThread: 0x60400046be80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-01-01 11:17:32.506224+0800 XXX[11341:1269987] operationBlock1</span><br><span class="line">2019-01-01 11:17:32.506513+0800 XXX[11341:1269987] operation1 Thread = &lt;NSThread: 0x600000474dc0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2019-01-01 11:17:32.506980+0800 XXX[11341:1269987] synchronousOperation....</span><br></pre></td></tr></table></figure>
<p>可以看到直到两秒之后才执行<code>NSLog(@&quot;synchronousOperation....&quot;);</code>也就是说NSOperation的执行是同步的。同时我们通过打印执行NSOperation任务的线程发现，同一个operaion内添加的多个任务，执行这些任务的线程并不是同一个。也就是说虽然NSOperation是同步的，但是operaion内部添加的任务可能是在不同线程中并发执行的，这些任务执行完成后才会向下执行，有点类似GCD的<code>dispatch_group</code>。</p>
<p>那么如何实现异步执行的NSOperation呢？可以通过两种方式：一种是通过创建NSOperation子类自己去实现异步操作，另外一种是通过NSOperationQueue。我们平时用的比较多的是通过使用NSOperationQueue来实现异步处理NSOperation。</p>
<h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p>通过<code>NSOperationQueue</code>来实现<code>NSOperation</code>的执行比较简单，直接将<code>NSOperation</code>放进<code>NSOperationQueue</code>的队列中就可以了。<code>NSOperationQueue</code>会自动为<code>NSOperation</code>创建线程并且调用它的<code>start</code>方法启动任务。当然<code>NSOperation</code>添加到<code>NSOperationQueue</code>中后也不一定会立刻被执行，如果<code>NSOperationQueue</code>中有很多个operation，当前的operation会在队列排到它以后自动执行。</p>
<p>通过NSOperationQueue来执行operation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将上面的代码改为NSOperationQueue来执行</span><br><span class="line">- (void)synchronousOperation &#123;</span><br><span class="line">    NSBlockOperation *operaion = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;operationBlock1&quot;);</span><br><span class="line">        NSLog(@&quot;operation1 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operaion addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operationBlock2&quot;);</span><br><span class="line">        NSLog(@&quot;operation2 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">//    [operaion start];</span><br><span class="line"></span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue addOperation:operaion];</span><br><span class="line">    NSLog(@&quot;synchronousOperation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-01-01 11:42:41.789280+0800 XXX[11463:1298262] synchronousOperation</span><br><span class="line">2019-01-01 11:42:41.789611+0800 XXX[11463:1298233] operationBlock2</span><br><span class="line">2019-01-01 11:42:41.791127+0800 XXX[11463:1298233] operation2 Thread = &lt;NSThread: 0x600000465680&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2019-01-01 11:42:43.790340+0800 XXX[11463:1298241] operationBlock1</span><br><span class="line">2019-01-01 11:42:43.790851+0800 XXX[11463:1298241] operation1 Thread = &lt;NSThread: 0x60400066a440&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到operation不会阻塞当前的线程，会自动的异步去执行任务。</p>
<h4 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h4><p>通过自定义NSOperation可以实现更多的定制化任务处理，例如异步执行NSOperation。自定义NSOperation要实现以下几个方法：</p>
<ul>
<li><code>start</code> ：在start方法中实现异步处理的操作，不论是调用异步处理函数还是说开启新的线程。而且要及时通过KVO更新operation当前的状态：<code>isExecuting</code>，<code>isFinished</code>，以便于通知它的监测者。</li>
<li><code>main</code> 官方文档中建议在这个方法中实现执行任务的操作。当然也可以不实现这个方法，直接在<code>start</code>中实现处理任务也可以。<code>SDWebImage</code>中的自定义operation就只实现了<code>start</code>方法。</li>
<li><code>isConcurrent</code>是否是并发，返回YES即可。</li>
<li><code>isExecuting</code>：是否正在执行</li>
<li><code>isFinished</code> 是否完成，包括任务完成和取消，取消也是<code>Finished</code>。</li>
</ul>
<p>我自己没有实现过自定义NSOperation，之前看<code>SDWebImage</code>的时候看过里面自定义<code>SDWebImageDownloaderOperation</code>类实现了异步处理图片下载请求，写了很多东西，要控制各种状态，并自行手动实现KVO（因为以上几种状态都是readonly），感兴趣的可以参考<a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。</p>
<h4 id="添加任务依赖"><a href="#添加任务依赖" class="headerlink" title="添加任务依赖"></a>添加任务依赖</h4><p>NSOperation可以指定任务间的依赖，一个任务A可以依赖于另外一个任务B，任务B没有执行完成，任务A不会开始执行。这里要注意的是，任务B不一定非要是执行成功，因为取消也算是完成<code>isFinished</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation2 addDependency:operaion1];</span><br></pre></td></tr></table></figure>
<p>添加依赖一定要在operation 执行<code>start</code>方法或者添加到NSOperationQueue前，否则无效。</p>
<p>而且这两个operation不一定非要是在同一个NSOperationQueue中，不同的NSOperationQueue中的operation也可以指定依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockOperationAction &#123;</span><br><span class="line">    NSBlockOperation *operaion1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;operation1&quot;);</span><br><span class="line">        NSLog(@&quot;operation1 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operation2&quot;);</span><br><span class="line">        NSLog(@&quot;operation2 Thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operation2 addDependency:operaion1];</span><br><span class="line"></span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue1 addOperation:operaion1];</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue2 addOperation:operation2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-01 12:29:44.008728+0800 XXX[11812:1350215] operation1</span><br><span class="line">2019-01-01 12:29:44.009073+0800 XXX[11812:1350215] operation1 Thread = &lt;NSThread: 0x60400047ca00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2019-01-01 12:29:44.009623+0800 XXX[11812:1350214] operation2</span><br><span class="line">2019-01-01 12:29:44.009877+0800 XXX[11812:1350214] operation2 Thread = &lt;NSThread: 0x60400047cac0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>NSOperation还有很多功能：</p>
<ul>
<li>可以通过<code>queuePriority</code>属性指定在队列中的优先级；</li>
<li>可以通过<code>setCompletionBlock:</code>方法设置任务完成的回调；</li>
<li>可以手动<code>cancel</code>取消掉一个任务；也可以通过调用<code>NSOperationQueue</code>的<code>cancelAllOperations</code>方法取消队列中所有的任务。</li>
<li>可以通过<code>NSOperationQueue</code>的<code>suspended</code>来暂停队列中的任务。不过它只是暂停operation queue调度新的任务，并不会暂停正在执行的任务。</li>
<li>还可以通过<code>NSOperationQueue</code>的<code>maxConcurrentOperationCount</code>属性来设置operation queue中任务的最大并发数。如果设置为1那就是串行执行。但是这里的串行执行顺序并不一定，要看当然operation的优先级和<code>isReady</code>的状态。</li>
</ul>
<p>NSOperation相对于GCD来说，提供的对于任务的控制很丰富很灵活，可以做很多事情。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzycodder.github.io/2019/01/01/Objective-C-四-多线程/" data-id="cjte261fs0005x6f1zftikwjj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C-四-多线程/">Objective-C-(四)-多线程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/14/Oracle学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2018/12/19/Objective-C-三-Block实现解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Objective-C-(三)Block实现解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C-一-对象、属性、方法/">Objective-C-(一)对象、属性、方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C-三-Block实现解析/">Objective-C-(三)Block实现解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C-二-内存管理/">Objective-C-(二)内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C-四-多线程/">Objective-C-(四)-多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/关于截图-renderInContext-drawViewHierarchyInRect/">关于截图(renderInContext && drawViewHierarchyInRect)</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Objective-C-一-对象、属性、方法/" style="font-size: 10px;">Objective-C-(一)对象、属性、方法</a> <a href="/tags/Objective-C-三-Block实现解析/" style="font-size: 10px;">Objective-C-(三)Block实现解析</a> <a href="/tags/Objective-C-二-内存管理/" style="font-size: 10px;">Objective-C-(二)内存管理</a> <a href="/tags/Objective-C-四-多线程/" style="font-size: 10px;">Objective-C-(四)-多线程</a> <a href="/tags/关于截图-renderInContext-drawViewHierarchyInRect/" style="font-size: 10px;">关于截图(renderInContext && drawViewHierarchyInRect)</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/14/Oracle学习/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/01/Objective-C-四-多线程/">Objective-C-(四)-多线程</a>
          </li>
        
          <li>
            <a href="/2018/12/19/Objective-C-三-Block实现解析/">Objective-C-(三)Block实现解析</a>
          </li>
        
          <li>
            <a href="/2018/12/14/Objective-C-二-内存管理/">Objective-C-(二)内存管理</a>
          </li>
        
          <li>
            <a href="/2018/12/10/关于截图的注意点-renderInContext-drawViewHierarchyInRect/">关于截图的注意点(renderInContext &amp;&amp; drawViewHierarchyInRect)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 zzy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>